[suck]
k: #execute => #halt
statusCode: _ => EVMC_REVERT
output: _ => _
callData: #abiCallData("suck", #address(V_u), #int256(Delta_D))
localMem: _
pc: 0 => _
wordStack: .WordStack => _
gas: Gas => _
log: _
callDepth: _
refund: _ => _
storage:
  0 |-> Root
  9 |-> #unsigned(V_p)
  10 |-> #unsigned(P)
  11 |-> (#unsigned(V) => _)
  12 |-> G
  (#hashedLocation("DappHub", 4, V_u) |-> (#unsigned(D_u) => _))
  _:Map
activeaccounts:
accounts:
requires:
  // andBool Gas >Int 100000
  // andBool #rangeAddress(V_u)
  // andBool #rangeAddress(User)
  // andBool #rangeAddress(Root)
  // andBool #rangeSInt(256, Delta_D)
  // andBool #rangeSInt(256, V_p)
  // andBool #rangeSInt(256, P)
  // andBool #rangeSInt(256, V)
  // andBool #rangeSInt(256, D_u)
  andBool 0 <=Int G andBool G <Int pow256
  // andBool #rangeUInt(256, G)
  // METAPROOF
  // this holds "inductively"
  // todo: add (V >=Int 0) and (D_u >=Int 0) as postconditions to successful case?
  // andBool V >=Int 0
  // andBool D_u >=Int 0
  // andBool User ==Int V_u
  // new case split:
  // case 1
  //andBool (Delta_D >=Int 0)
  // case 2
  //andBool notBool (Delta_D >=Int 0)
  // tactic: case splitting the spec
  // case 1A
  //andBool (Delta_D >Int V)
  //andBool (D_u +Int Delta_D <Int 0)
  // case 1B
  //andBool notBool (Delta_D >Int V)
  //andBool (D_u +Int Delta_D <Int 0)
  // case 2A
  //andBool (Delta_D >Int V)
  //andBool notBool (D_u +Int Delta_D <Int 0)
  // case 2B (problematic!)
  //andBool notBool (Delta_D >Int V)
  //andBool notBool (D_u +Int Delta_D <Int 0)
  //andBool notBool (
  //  Root ==Int CALLER_ID
  //  andBool #rangeSInt(256, V -Int Delta_D)
  //  andBool V -Int Delta_D >=Int 0
  //  andBool #rangeSInt(256, D_u +Int Delta_D)
  //  andBool D_u +Int Delta_D >=Int 0
  //)
attribute:

